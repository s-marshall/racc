= Racc Grammar File Reference

== Global Structure

== Class Block and User Code Block

The top level is divided into a class block and a user code block. 
The user code block must be after the class definition in the class block.

== Comment

Comments can be inserted almost anywhere in the grammar file except for a few exceptions. The two styles of comments are the
Ruby style (#.....) and the C style (/*......*/) .

== Class Block

The class block has the following form.

 class CLASS_NAME [< superclass]
   [precedence]
   [token declarations]
   [options]
   [expected number of S/R conflict]
   [token symbol conversion]
   [start rule]
 rule
   grammar description
 end

CLASS_NAME is a name of parser class.
This is the Ruby name of generated parser class.

If CLASS_NAME includes '::' as in M::C, the class definition is nested in the module M.

 module M
   class C
     :
     :
   end
 end

In addition, a superclass can be specified in the same syntax as Ruby. However, this superclass greatly affects
parser operation and is not specified unless particularly needed. This is provided for future extensions, but does
not have to specified currently.

== Grammar Block

The grammar block describes a grammar which is can be recognized by the parser generated by racc.
The grammar can be written as follows between the reserved words rule and end, and has the syntax below.

 (token): (token) (token) (token).... (action)

 (token): (token) (token) (token).... (action)
       | (token) (token) (token).... (action)
       | (token) (token) (token).... (action)

(action) is the action executed when the corresponding (token)s are found.
(action) is a Ruby code block surrounded by curly braces. The (action) can be omitted.
If omitted, the empty string '' is used.

--

{ print val[0]
  puts val[1] }

--

Almost all Ruby statements can be used in actions, but some cannot be used. The unusable statements are:

--
 * here document
 * =begin...-end comment
 * regular expression beginning with whitespace
 * % operator and %r regular expression
--

These are very hard problems and will probably not be completely solved.

The return method of left-hand side value ($$) is changed by an option. By default, the local variable result (val[0] is
the default) represents the left-hand side value. When the action block is omitted, the result value becomes
the left-hand side value. When this value is explicitly returned by return, this value becomes the result.
If no_result_var is specified in options, the left-hand side value becomes the value of the last statement
in the action block (same as in a Ruby method).

In both cases, the action can be omitted, and if the action is omitted, the left-hand side value is always val[0].

Here is an example of an entire grammar block.
--
rule
  goal: definition rules source { result = val }

  definition: /* none */   { result = [] }
    | definition startdesig  { result[0] = val[1] }
    | definition
             precrule   # this line continues from the above line
             {
               result[1] = val[1]
             }

  startdesig: START TOKEN
--

You can use the special variables in an action. Examples of these variables are shown below.
The content in the parentheses is a yacc expression.

  * result ($$)

The value of left-hand side (lhs). A default value is val[0].

  * val ($1,$2,$3...)

An array of value of right-hand side (rhs).

  * _values (...$-2,$-1,$0)

A stack of values.
DO NOT MODIFY this stack unless you know what you are doing.

== Operator Precedance

This function is equal to '%prec' in yacc.
To designate this block:
--
prechigh
  nonassoc '++'
  left     '*' '/'
  left     '+' '-'
  right    '='
preclow
--
`right' is yacc's %right, `left' is yacc's %left.

`=' + (symbol) means yacc's %prec:
--
prechigh
  nonassoc UMINUS
  left '*' '/'
  left '+' '-'
preclow

rule
  exp: exp '*' exp
     | exp '-' exp
     | '-' exp       =UMINUS   # equals to "%prec UMINUS"
         :
         :
--

== expect

Racc has bison's "expect" directive.
--
# Example

class MyParser
rule
  expect 3
    :
    :
--
This directive declears "expected" number of shift/reduce conflict.
If "expected" number is equal to real number of conflicts,
racc does not print confliction warning message.

== Declaring Tokens

By declaring tokens, you can avoid many meanless bugs.
If decleared token does not exist/existing token does not decleared,
Racc output warnings.  Declearation syntax is:
--
token TOKEN_NAME AND_IS_THIS
      ALSO_THIS_IS AGAIN_AND_AGAIN THIS_IS_LAST
--

== Options

You can write options for racc command in your racc file.
--
options OPTION OPTION ...
--
Options are:

  * omit_action_call

omit empty action call or not.

  * result_var

use/does not use local variable "result"

You can use 'no_' prefix to invert its meanings.

== Converting Token Symbol

Token symbols are, as default,

  * naked token string in racc file (TOK, XFILE, this_is_token, ...)
    --&gt; symbol (:TOK, :XFILE, :this_is_token, ...)
  * quoted string (':', '.', '(', ...)
    --&gt; same string (':', '.', '(', ...)

You can change this default by "convert" block.
Here is an example:
--
convert
  PLUS 'PlusClass'      # We use PlusClass for symbol of `PLUS'
  MIN  'MinusClass'     # We use MinusClass for symbol of `MIN'
end
--
We can use almost all ruby value can be used by token symbol,
except 'false' and 'nil'.  These are causes unexpected parse error.

If you want to use String as token symbol, special care is required.
For example:
--
convert
  class '"cls"'            # in code, "cls"
  PLUS '"plus\n"'          # in code, "plus\n"
  MIN  "\"minus#{val}\""   # in code, \"minus#{val}\"
end
--

== Start Rule

'%start' in yacc. This changes start rule.
--
start real_target
--
This statement will not be used forever, I think.

== User Code Block

"User Code Block" is a Ruby source code which is copied to output.
There are three user code block, "header" "inner" and "footer".

Format of user code is like this:
--
---- header
  ruby statement
  ruby statement
  ruby statement

---- inner
  ruby statement
     :
     :
--
If four '-' exist on line head,
racc treat it as beginning of user code block.
A name of user code must be one word.
